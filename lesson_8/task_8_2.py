# 2. [Задача со звездочкой]: усложненный вариант задания
# 1. Написать регулярное выражение для парсинга файла логов web-сервера из ДЗ 6 урока nginx_logs.txt
# Техническое задание:
#
# Лог файл: https://github.com/elastic/examples/raw/master/Common%20Data%20Formats/nginx_logs/nginx_logs
# Функция парсинга строки лог-файла:
# Принимает аргумент - строку (по шаблону из лог-файла)
# возвращает кортеж из 6 элементов вида: (<remote_addr>, <request_datetime>, <request_type>, <requested_resource>, <response_code>, <response_size>)
# Вы можете не обращать внимание на IPv6 или явно учесть их в регулярном выражении, это будет очень хорошо.
# Проверьте работоспособность функции на нескольких строках лог файла.
# Распарсите весь файл и выведите на экран все IP, без повторений.
# Примеры/Тесты:
#
#
# raw = '188.138.60.101 - - [17/May/2015:08:05:49 +0000] "GET /downloads/product_2 HTTP/1.1" 304 0 "-" "Debian APT-HTTP/1.3 (0.9.7.9)"'
# parsed_raw = ('188.138.60.101', '17/May/2015:08:05:49 +0000', 'GET', '/downloads/product_2', '304', '0')
#
# Усложнение:
#
# Ваша функция должна корректно обрабатывать как IPv4, так и IPv6 - найдите их в логе.
# Посмотрите спецификацию IPv6. Что такое шестнадцатеричное число и какие буквы/цифры оно может включать. Сколько их может быть в IPv6.
# Совсем хорошо, если вы обработаете cокращенные адреса IPv6, которые тоже в логе есть. Это не обязательно.
# Ваш шаблон должен пропускать только то, что нужно, не используйте «избыточно широкие» шаблоны.


# (?P<remote_addr>(?:^(?::)(?::[0-9A-f]+){1,7})|(?:[0-9A-f]{3,4}:{1,2}){1,7}(?:[0-9A-f]+)|(?:\d{1,3}\.){3}\d{1,3}).{6}(?P<request_datetime>\d{2}\/\w{3}\/\d{4}:\d{2}:\d{2}:\d{2}\ \+\d{4}).+\"(?P<request_type>\w+).(?P<requested_resource>\/\w+\/\w+).\w+\/\d+.\d+.\s+(?P<response_code>\d+)\s(?P<response_size>\d+)
# lines_content = re.compile(r'(?P<search_line>.+[^\n])')

from requests import get, utils
import re

# создаем функцию, принимающую в качестве параметра log-файл, который будем парсить
def log_parse(content):
    count = 0
    i = 0  # промежуточный (начальный) счетчик для среза строки content
    set_ip_out = set()  # объявляем переменную-множество, куда будут складироваться все IP-адреса, чтоб были без повтора по условию задачи
    for line in content:  # что не создавать путей, новыъ файлов, пробежимся прямо по content
        count += 1
        if line == '\n':
            line_out_content = content[i:count - 1]  #  построчный срез из log-файла
            i = count  #  запоминаем место останова среза для учета в следующей строке
            # далее парсим полученные срезы с помощью регулярки. да, она длинная, но она специально для этого log-файла
            # можно было искать не полное соответствие, а каждый элемент отдельно (но это другая история)
            parsed_out = re.search(r'(?P<remote_addr>(?:^(?::)(?::[0-9A-f]+){1,7})'
                                     r'|(?:[0-9A-f]{3,4}:{1,2}){1,7}(?:[0-9A-f]+)'
                                     r'|(?:\d{1,3}\.){3}\d{1,3}).{6}'
                                     r'(?P<request_datetime>\d{2}\/\w{3}\/\d{4}:\d{2}:\d{2}:\d{2}\ \+\d{4}).+\"'
                                     r'(?P<request_type>\w+).'
                                     r'(?P<requested_resource>\/\w+\/\w+).\w+\/\d+.\d+.\s+'
                                     r'(?P<response_code>\d+)\s(?P<response_size>\d+)', line_out_content).groups()
            # print(parsed_out)  # это можно и расскоментить - будет печать всех findallов в виде кортежей,
            # но по условия задачи выводим только все IP, без повторений
            set_ip_out.add(parsed_out[0])  # собираем все IP (множество само уберет повторы)
    return set_ip_out  # возвращаем все IP (только IP), без повторений


url = get('https://raw.githubusercontent.com/elastic/examples/master/Common%20Data%20Formats/nginx_logs/nginx_logs') # проверка связи
encodings = utils.get_encoding_from_headers(url.headers)
content = url.content.decode(encoding=encodings)
print(log_parse(content))  # и печатаем их
